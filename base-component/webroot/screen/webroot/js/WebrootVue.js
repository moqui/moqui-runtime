/* This software is in the public domain under CC0 1.0 Universal plus a Grant of Patent License. */

/* TODO:
 - make sure link to same screen with different parameters is working
 - going to minimal path causes menu reload; avoid? better to cache menus and do partial requests...

 - support dual mode, server and client rendered in parallel
   - in Header.html.ftl somehow drop screenName class on body (only for vue rendering...)
   - use something other than apps.xml as root for vue to allow in parallel? (vapps.xml, still use /apps as basePath)

 - some approach for loading additional scripts and stylesheets
   - current adds to html_scripts, html_stylesheets, etc doesn't work when header not reloaded
   - one workaround is to use inline script and link elements (see MyCalendar.xml screen in SimpleScreens)

 - anchor (a) only used for link if UrlInstance.isScreenUrl() is false which looks only at default-response for url-type=plain or
   type=none; if a transition has conditional or error responses of different types it won't response properly
   - consider changing loadComponent to pass a header telling ScreenRenderImpl that it is for a component
   - in ScreenRenderImpl if we are sending back content handle some other way...
   - in SRI if redirecting to screen send JSON obj with screenUrl or for non-screen redirectUrl

 - use vue-aware widgets or add vue component wrappers for scripts and widgets
 - remove as many inline m-script elements as possible...
 - add fully client rendered version of form-list when it has data prep embedded
   - current form-list.entity-find with special transition to get for data by name and current + paginate parameters
   - add form-list.rest-entity, rest-service (or just rest-call?), and maybe service-call/actions/etc
 - add dynamic loading tabs component for subscreens-menu and subscreens-panel

 - use something else for jstree and JSON to populate it generated by ScreenTree.groovy
   - working on HM ProjectSummary
   - dynamic-container load doesn't work quite right in MessageThread


 - big new feature for client rendered screens
   - on the server render to a Vue component object in JS file following pattern of MyAccountNav.js with define()
   - let vue component object have no template, using loadComponent feature to download same url with .html to get template string
   - make these completely static, not dependent on any inline data, so they can be cached
   - add caching of component objects to loadComponent; perhaps 20 (50?) item LRU array
   - separate request(s) to get data to populate
 - screen structure (Vue specific...)
   - use existing XML Screen with a new client-template and other elements?
   - if called from load component (identify with header) return js, or with .html extension return template string
   - client-template element with vue template (ie pseudo html with JS expressions)
   - client-template would still be simplified using Moqui library of Vue components
   - other elements for vue properties like data, methods, mounted/etc lifecycle, computed, watch, etc
   - can these be compatible with other tools like Angular2, React, etc or need something higher level?
 - screen structure for any client library (Angular2, React, etc) possible?
   - goal would be to use FTL macros to transform more detailed XML into library specific output
 */

// simple stub for define if it doesn't exist (ie no require.js, etc); mimic pattern of require.js define()
if (!window.define) window.define = function(name, deps, callback) {
    if (typeof name !== 'string') { callback = deps; deps = name; name = null; }
    if (Object.prototype.toString.call(deps) !== '[object Array]') { callback = deps; deps = null; }
    if (Object.prototype.toString.call(callback) === '[object Function]') { return callback(); } else { return callback }
};

const notifyOpts = { delay:6000, offset:{x:20,y:70}, type:'success', animate:{ enter:'animated fadeInDown', exit:'animated fadeOutUp' } };

function handleAjaxError(jqXHR, textStatus, errorThrown) {
    console.log('ajax ' + textStatus + ' (' + jqXHR.status + '), message ' + errorThrown + '; response text: ' + jqXHR.responseText); // console.log(jqXHR);
    // reload on 401 (Unauthorized) so server can remember current URL and redirect to login screen
    if (jqXHR.status == 401) { window.location.reload(true); }
    else if (jqXHR.status == 0) { $.notify({ message:'Could not connect to server' }, $.extend({}, notifyOpts, {delay:10000, type:'danger'})); }
    else { $.notify({ message:'Error: ' + errorThrown + ' (' + textStatus + ')' }, $.extend({}, notifyOpts, {delay:10000, type:'danger'})); }
}
// NOTE: this may eventually split to change the activeSubscreens only on currentPathList change (for screens that support it)
//     and if ever needed some sort of data refresh if currentParameters changes
function loadComponent(url, callback, divId) {
    var questIdx = url.indexOf('?');
    var path = questIdx > 0 ? url.slice(0, questIdx) : url;
    var isJsPath = path.slice(-3) == '.js';
    if (isJsPath) { url = path; } else { url = path + '.vuet' + (questIdx > 0 ? url.slice(questIdx)  : ''); }
    console.log("loading " + url + " id " + divId);
    $.ajax({ type:"GET", url:url, error:handleAjaxError, success: function(resp) {
        // console.log(resp);
        if (!resp) { callback(NotFound); }
        if (Object.prototype.toString.call(resp) == '[object String]' && resp.length > 0) {
            if (isJsPath || resp.slice(0,7) == 'define(') {
                console.log("loaded JS " + url + " id " + divId);
                var compObj = eval(resp);
                if (compObj.template) { callback(compObj); } else {
                    var htmlUrl = (path.slice(-3) == '.js' ? path.slice(0, -3) : path) + '.vuet';
                    $.ajax({ type:"GET", url:htmlUrl, error:handleAjaxError, success: function (htmlText) {
                        compObj.template = htmlText; callback(compObj); }});
                }
            } else {
                var templateText = resp.replace(/<script/g, '<m-script').replace(/<\/script>/g, '</m-script>');
                console.log("loaded HTML template " + url + (divId ? " id " + divId : "") /* + ": " + templateText*/);
                callback({ template: '<div' + (divId && divId.length > 0 ? ' id="' + divId + '"' : '') + '>' + templateText + '</div>' });
            }
        } else if (resp === Object(resp)) {
            if (resp.screenUrl && resp.screenUrl.length > 0) { this.$root.goto(resp.screenUrl); }
            else if (resp.redirectUrl && resp.redirectUrl.length > 0) { window.location.replace(resp.redirectUrl); }
        } else { callback(NotFound); }
    }});
}

const NotFound = Vue.extend({ template: '<div id="current-page-root"><h4>Screen not found at {{this.$root.currentPath}}</h4></div>' });
const EmptyComponent = Vue.extend({ template: '<div id="current-page-root"><img src="/images/wait_anim_16x16.gif" alt="Loading..."></div>' });

/* ========== inline components ========== */
Vue.component('m-link', {
    props: { href:{type:String,required:true}, loadId:String },
    template: '<a :href="linkHref" @click.prevent="go"><slot></slot></a>',
    methods: { go: function() { if (this.loadId && this.loadId.length > 0) { this.$root.loadContainer(this.loadId, this.href); }
        else { this.$root.goto(this.href); } }},
    computed: { linkHref: function () { return this.href.indexOf(this.$root.basePath) == 0 ? this.href.replace(this.$root.basePath, this.$root.linkBasePath) : this.href; } }
});
Vue.component('m-script', {
    template: '<div style="display:none;"><slot></slot></div>',
    mounted: function() {
        var parent = this.$el.parentElement; var s = document.createElement('script');
        if (this.$el.hasAttribute('src')) s.setAttribute('src', this.$el.getAttribute('src'));
        if (this.$el.hasAttribute('type')) s.setAttribute('type', this.$el.getAttribute('type'));
        s.appendChild(document.createTextNode(this.$el.innerText)); Vue.util.remove(this.$el); parent.appendChild(s);
    }
});
Vue.component('container-dialog', {
    props: { id:{type:String,required:true}, title:String, width:{type:String,default:'760'}, openDialog:{type:Boolean,default:false} },
    data: function() { return { isHidden:true, dialogStyle:{width:this.width + 'px'}}},
    template:
    '<div :id="id" class="modal dynamic-dialog" aria-hidden="true" style="display: none;" tabindex="-1">' +
        '<div class="modal-dialog" :style="dialogStyle"><div class="modal-content">' +
            '<div class="modal-header"><button type="button" class="close" data-dismiss="modal" aria-hidden="true">&times;</button>' +
                '<h4 class="modal-title">{{title}}</h4></div>' +
            '<div class="modal-body"><slot></slot></div>' +
        '</div></div>' +
    '</div>',
    methods: { hide: function() { $(this.$el).modal('hide'); } },
    mounted: function() {
        var jqEl = $(this.$el); var vm = this;
        jqEl.on("hidden.bs.modal", function() { vm.isHidden = true; });
        jqEl.on("shown.bs.modal", function() { vm.isHidden = false;
                jqEl.find(":not(.noselect2)>select:not(.noselect2)").select2({ }); jqEl.find(".default-focus").focus(); });
        if (this.openDialog) { jqEl.modal('show'); }
    }
});
Vue.component('dynamic-container', {
    props: { id:{type:String,required:true}, url:{type:String} },
    data: function() { return { curComponent:EmptyComponent, curUrl:"" } },
    template: '<component :is="curComponent"></component>',
    methods: { reload: function() { var saveUrl = this.curUrl; this.curUrl = ""; var vm = this; setTimeout(function() { vm.curUrl = saveUrl; }, 20); },
        load: function(url) { this.curUrl = url; }},
    watch: { curUrl: function(newUrl) {
        if (!newUrl || newUrl.length === 0) { this.curComponent = EmptyComponent; return; }
        var vm = this; loadComponent(newUrl, function(comp) { vm.curComponent = comp; }, this.id);
    }},
    mounted: function() { this.$root.addContainer(this.id, this); this.curUrl = this.url; }
});
Vue.component('dynamic-dialog', {
    props: { id:{type:String,required:true}, url:{type:String,required:true}, title:String, width:{type:String,default:'760'},
        openDialog:{type:Boolean,default:false} },
    data: function() { return { curComponent:EmptyComponent, curUrl:"", isHidden:true, dialogStyle:{width:this.width + 'px'}}},
    template:
    '<div :id="id" class="modal dynamic-dialog" aria-hidden="true" style="display: none;" tabindex="-1">' +
        '<div class="modal-dialog" :style="dialogStyle"><div class="modal-content">' +
            '<div class="modal-header"><button type="button" class="close" data-dismiss="modal" aria-hidden="true">&times;</button>' +
                '<h4 class="modal-title">{{title}}</h4></div>' +
            '<div class="modal-body"><component :is="curComponent"></component></div>' +
        '</div></div>' +
    '</div>',
    methods: {
        reload: function() { if (!this.isHidden) { var jqEl = $(this.$el); jqEl.modal('hide'); jqEl.modal('show'); }},
        load: function(url) { this.curUrl = url; }, hide: function() { $(this.$el).modal('hide'); }
    },
    watch: { curUrl: function (newUrl) { if (!newUrl || newUrl.length === 0) { this.curComponent = EmptyComponent; return; }
        var vm = this; loadComponent(newUrl, function(comp) { vm.curComponent = comp; }, this.id); }},
    mounted: function() {
        this.$root.addContainer(this.id, this); var jqEl = $(this.$el); var vm = this;
        jqEl.on("show.bs.modal", function() { vm.curUrl = vm.url; });
        jqEl.on("hidden.bs.modal", function() { vm.isHidden = true; vm.curUrl = ""; });
        jqEl.on("shown.bs.modal", function() { vm.isHidden = false;
                jqEl.find(":not(.noselect2)>select:not(.noselect2)").select2({ }); jqEl.find(".default-focus").focus(); });
        if (this.openDialog) { jqEl.modal('show'); }
    }
});
Vue.component('m-editable', {
    props: { id:{type:String,required:true}, labelType:{type:String,default:'span'}, labelValue:{type:String,required:true},
        url:{type:String,required:true}, urlParameters:{type:Object,default:{}},
        parameterName:{type:String,default:'value'}, widgetType:{type:String,default:'textarea'},
        loadUrl:String, loadParameters:Object, indicator:{type:String,default:'Saving'}, tooltip:{type:String,default:'Click to edit'},
        cancel:{type:String,default:'Cancel'}, submit:{type:String,default:'Save'} },
    mounted: function() {
        var reqData = $.extend({ moquiSessionToken:this.$root.moquiSessionToken, parameterName:this.parameterName }, this.urlParameters);
        var edConfig = { indicator:this.indicator, tooltip:this.tooltip, cancel:this.cancel, submit:this.submit,
                name:this.parameterName, type:this.widgetType, cssclass:'editable-form', submitdata:reqData };
        if (this.loadUrl && this.loadUrl.length > 0) {
            var vm = this; edConfig.loadurl = this.loadUrl; edConfig.loadtype = "POST";
            edConfig.loaddata = function(value) { return $.extend({ currentValue:value, moquiSessionToken:vm.$root.moquiSessionToken }, vm.loadParameters); };
        }
        $(this.$el).editable(this.url, edConfig);
    },
    render: function(createEl) { return createEl(this.labelType, { attrs:{ id:this.id, class:'editable-label' }, domProps: { innerHTML:this.labelValue } }); }
});
/* ========== form components ========== */
Vue.component('m-form', {
    props: { action:{type:String,required:true}, method:{type:String,default:'POST'},
        submitMessage:String, submitReloadId:String, submitHideId:String, focusField:String, noValidate:Boolean },
    data: function() { return { fields:{} }},
    template: '<form @submit.prevent="submitForm" class="validation-engine-init"><slot></slot></form>',
    methods: {
        submitForm: function submitForm() {
            var jqEl = $(this.$el); var otherParms = $.extend({ moquiSessionToken:this.$root.moquiSessionToken }, this.fields);
            var $btn = $(document.activeElement);
            if ($btn.length && jqEl.has($btn) && $btn.is('button[type="submit"], input[type="submit"], input[type="image"]') && $btn.is('[name]')) {
                otherParms[$btn.attr('name')] = $btn.val(); }
            // console.log('m-form parameters ' + jqEl.formSerialize()); console.log('m-form other parameters ' + JSON.stringify(otherParms));
            if (this.noValidate || jqEl.valid()) { jqEl.ajaxSubmit({ resetForm:false, type:this.method, url:this.action,
                data:otherParms, headers:{Accept:'application/json'}, error:handleAjaxError, success:this.handleResponse }); }
        },
        handleResponse: function(resp) {
            var notified = false;
            console.log('m-form response ' + JSON.stringify(resp));
            if (resp && resp === Object(resp)) {
                if (resp.messages) for (var mi=0; mi < resp.messages.length; mi++) {
                    $.notify({ message:resp.messages[mi] }, $.extend({}, notifyOpts, {type:'info'})); notified = true; }
                if (resp.errors) for (var ei=0; ei < resp.messages.length; ei++) {
                    $.notify({ message:resp.messages[ei] }, $.extend({}, notifyOpts, {delay:60000, type:'danger'})); notified = true; }
                if (resp.screenUrl && resp.screenUrl.length > 0) { this.$root.goto(resp.screenUrl); }
                else if (resp.redirectUrl && resp.redirectUrl.length > 0) { window.location.href = resp.redirectUrl; }
            } else { console.log('m-form no reponse or non-JSON response: ' + JSON.stringify(resp)) }
            if (this.submitHideId && this.submitHideId.length > 0) { $('#' + this.submitHideId).modal('hide'); }
            if (this.submitReloadId && this.submitReloadId.length > 0) { this.$root.reloadContainer(this.submitReloadId); }
            var msg = this.submitMessage && this.submitMessage.length > 0 ? this.submitMessage : (notified ? null : "Form data saved");
            if (msg) $.notify({ message:msg }, $.extend({}, notifyOpts, {type:'success'}));
        }
    },
    mounted: function() {
        var jqEl = $(this.$el);
        if (!this.noValidate) jqEl.validate({ errorClass: 'help-block', errorElement: 'span',
            highlight: function(element, errorClass, validClass) { $(element).parents('.form-group').removeClass('has-success').addClass('has-error'); },
            unhighlight: function(element, errorClass, validClass) { $(element).parents('.form-group').removeClass('has-error').addClass('has-success'); }
        });
        jqEl.find('[data-toggle="tooltip"]').tooltip();
        if (this.focusField && this.focusField.length > 0) jqEl.find('[name=' + this.focusField + ']').addClass('default-focus').focus();
    }
});
Vue.component('form-link', {
    props: { action:{type:String,required:true}, focusField:String, noValidate:Boolean },
    data: function() { return { fields:{} }},
    template: '<form @submit.prevent="submitForm" class="validation-engine-init"><slot></slot></form>',
    methods: {
        submitForm: function submitForm() {
            var jqEl = $(this.$el); if (this.noValidate || jqEl.valid()) {
                var otherParms = this.fields;
                var parmStr = ""; var parmList = jqEl.formSerialize().split("&");
                for (var parmName in otherParms) { if (otherParms.hasOwnProperty(parmName)) {
                    if (parmStr.length > 0) { parmStr += '&'; } parmStr += (parmName + '=' + otherParms[parmName]); }}
                var extraList = []; var plainKeyList = [];
                for (var pi=0; pi<parmList.length; pi++) {
                    var parm = parmList[pi]; var parmSplit = parm.split("="); var key = parmSplit[0];
                    if (parmSplit.length < 2 || parmSplit[1].length == 0 || key == "moquiSessionToken" || key.indexOf('%5B%5D') > 0) continue;
                    if (key.indexOf("_op") > 0 || key.indexOf("_not") > 0 || key.indexOf("_ic") > 0) { extraList.push(parm); }
                    else { plainKeyList.push(key); if (parmStr.length > 0) { parmStr += '&'; } parmStr += parm; }
                }
                for (var ei=0; ei<extraList.length; ei++) {
                    var eparm = extraList[ei]; var keyName = eparm.substring(0, eparm.indexOf('_'));
                    if (plainKeyList.indexOf(keyName) >= 0) { if (parmStr.length > 0) { parmStr += '&'; } parmStr += eparm; }
                }
                var url = this.action;
                if (url.indexOf('?') > 0) { url = url + '&' + parmStr; } else { url = url + '?' + parmStr; }
                this.$root.goto(url);
            }
        }
    },
    mounted: function() {
        var jqEl = $(this.$el);
        if (!this.noValidate) jqEl.validate({ errorClass: 'help-block', errorElement: 'span',
            highlight: function(element, errorClass, validClass) { $(element).parents('.form-group').removeClass('has-success').addClass('has-error'); },
            unhighlight: function(element, errorClass, validClass) { $(element).parents('.form-group').removeClass('has-error').addClass('has-success'); }
        });
        jqEl.find('[data-toggle="tooltip"]').tooltip();
        if (this.focusField && this.focusField.length > 0) jqEl.find('[name=' + this.focusField + ']').addClass('default-focus').focus();
    }
});
/* ========== form field widget components ========== */
Vue.component('drop-down', {
    props: { options:Array, value:[Array,String], combo:Boolean, allowEmpty:Boolean, multiple:String,
        optionsUrl:String, optionsParameters:Object, labelField:String, valueField:String, dependsOn:Object },
    data: function() { return { curData: null, s2Opts: null } },
    template: '<select><slot></slot></select>',
    methods: {
        populateFromUrl: function() {
            if (!this.optionsUrl || this.optionsUrl.length === 0) return;
            var hasAllParms = true; var dependsOnMap = this.dependsOn; var parmMap = this.optionsParameters;
            var reqData = { moquiSessionToken: this.$root.moquiSessionToken };
            for (var parmName in parmMap) { if (parmMap.hasOwnProperty(parmName)) reqData[parmName] = parmMap[parmName]; }
            for (var doParm in dependsOnMap) { if (dependsOnMap.hasOwnProperty(doParm)) {
                var doValue = $('#' + dependsOnMap[doParm]).val(); if (!doValue) { hasAllParms = false; break; } reqData[doParm] = doValue; }}
            if (!hasAllParms) { this.curData = null; return; }
            var vm = this; $.ajax({ type:"POST", url:this.optionsUrl, data:reqData, dataType:"json", error:handleAjaxError, success: function(list) { if (list) {
                var newData = []; if (vm.allowEmpty) newData.push({ id:'', text:'' });
                var labelField = vm.labelField; if (!labelField) labelField = "label";
                var valueField = vm.valueField; if (!valueField) valueField = "value";
                $.each(list, function(idx, curObj) { newData.push({ id: curObj[valueField], text: curObj[labelField] }) });
                vm.curData = newData;
            }}});
        }
    },
    mounted: function() {
        var vm = this; var opts = { minimumResultsForSearch:15 };
        if (this.combo) { opts.tags = true; opts.tokenSeparators = [',',' ']; }
        if (this.multiple == "multiple") { opts.multiple = true; }
        if (this.options && this.options.length > 0) { opts.data = this.options; }
        this.s2Opts = opts; var jqEl = $(this.$el);
        jqEl.select2(opts).on('change', function () { vm.$emit('input', this.value); })
            .on('select2:select', function () { jqEl.select2('open').select2('close'); });
        if (this.value && this.value.length > 0) { this.curVal = this.value; }
        if (this.optionsUrl && this.optionsUrl.length > 0) {
            var dependsOnMap = this.dependsOn;
            for (var doParm in dependsOnMap) { if (dependsOnMap.hasOwnProperty(doParm)) {
                $('#' + dependsOnMap[doParm]).on('change', function() { vm.populateFromUrl(); }); }}
            this.populateFromUrl();
        }
    },
    computed: { curVal: { get: function() { return $(this.$el).select2().val(); },
        set: function(value) { $(this.$el).select2().val(value).trigger('select2:change'); } } },
    watch: { value: function(value) { this.curVal = value; }, options: function(options) { this.curData = options; },
        curData: function(options) { this.s2Opts.data = options; $(this.$el).select2(this.s2Opts); } },
    destroyed: function() { $(this.$el).off().select2('destroy') }
});
Vue.component('text-autocomplete', {
    props: { id:{type:String,required:true}, name:{type:String,required:true}, value:String, valueText:String,
        type:String, size:String, maxlength:String, disabled:Boolean, validationClasses:String, dataVvValidation:String,
        required:Boolean, pattern:String, tooltip:String, form:String,
        url:{type:String,required:true}, dependsOn:Object, acParameters:Object, minLength:Number, showValue:Boolean, useActual:Boolean, skipInitial:Boolean },
    template:
    '<span><input ref="acinput" :id="acId" :name="acName" :type="type" :value="valueText" :size="size" :maxlength="maxlength" :disabled="disabled"' +
        ' :class="allClasses" :data-vv-validation="validationClasses" :required="required" :pattern="pattern"' +
        ' :data-toggle="tooltipToggle" :title="tooltip" autocomplete="off" :form="form">' +
        '<input ref="hidden" :id="id" type="hidden" :name="name" :value="value" :form="form">' +
        '<span ref="show" v-if="showValue" :id="showId" class="form-autocomplete-value">{{valueText}}</span>' +
    '</span>',
    computed: { acId: function() { return this.id + '_ac'; }, acName: function() { return this.name + '_ac'; },
        allClasses: function() { return 'form-control typeahead' + (this.validationClasses ? ' ' + this.validationClasses : ''); },
        showId: function() { return this.id + '_show'; }, tooltipToggle: function() { return this.tooltip && this.tooltip.length > 0 ? 'tooltip' : null; }
    },
    mounted: function() {
        var vm = this; var acJqEl = $(this.$refs.acinput); var hidJqEl = $(this.$refs.hidden);
        var showJqEl = this.$refs.show ? $(this.$refs.show) : null;
        acJqEl.typeahead({ minLength:(this.minLength ? this.minLength : 1), highlight:true, hint:false }, { limit:20,
            source: function(query, syncResults, asyncResults) {
                var dependsOnMap = vm.dependsOn; var parmMap = vm.acParameters;
                var reqData = { term: query, moquiSessionToken: vm.$root.moquiSessionToken };
                for (var parmName in parmMap) { if (parmMap.hasOwnProperty(parmName)) reqData[parmName] = parmMap[parmName]; }
                for (var doParm in dependsOnMap) { if (dependsOnMap.hasOwnProperty(doParm)) {
                    var doValue = $('#' + dependsOnMap[doParm]).val(); if (doValue) reqData[doParm] = doValue; }}
                $.ajax({ url: vm.url, type:"POST", dataType:"json", data:reqData, error:handleAjaxError, success: function(data) {
                    asyncResults($.map(data, function(item) { return { label:item.label, value:item.value } })); }});
            }, display: function(item) { return item.label; }
        });
        acJqEl.bind('typeahead:select', function(event, item) {
            if (item) { this.value = item.value; hidJqEl.val(item.value); hidJqEl.trigger("change"); acJqEl.val(item.label);
                if (showJqEl && item.label) { showJqEl.html(item.label); } return false; }
        });
        acJqEl.change(function() { if (!acJqEl.val()) { hidJqEl.val(""); hidJqEl.trigger("change"); }
                else if (this.useActual) { hidJqEl.val(acJqEl.val()); hidJqEl.trigger("change"); } });
        var dependsOnMap = this.dependsOn;
        for (var doParm in dependsOnMap) { if (dependsOnMap.hasOwnProperty(doParm)) {
            $('#' + dependsOnMap[doParm]).change(function() { hidJqEl.val(""); acJqEl.val(""); }); }}
        if (!this.skipInitial && hidJqEl.val()) {
            var parmMap = this.acParameters;
            var reqData = { term: hidJqEl.val(), moquiSessionToken: this.$root.moquiSessionToken };
            for (var parmName in parmMap) { if (parmMap.hasOwnProperty(parmName)) reqData[parmName] = parmMap[parmName]; }
            for (doParm in dependsOnMap) { if (dependsOnMap.hasOwnProperty(doParm)) {
                var doValue = $('#' + dependsOnMap[doParm]).val(); if (doValue) reqData[doParm] = doValue; }}
            $.ajax({ url:this.url, type:"POST", dataType:"json", data:reqData, error:handleAjaxError, success: function(data) {
                var curValue = hidJqEl.val();
                for (var i = 0; i < data.length; i++) { if (data[i].value == curValue) {
                    acJqEl.val(data[i].label); if (showJqEl) { showJqEl.html(data[i].label); } break; }}
            }});
        }
    }
});

/* ========== webrootVue - root Vue component with router ========== */
Vue.component('subscreens-tabs', {
    data: function() { return { pathIndex:-1 }},
    template:
    '<ul v-if="subscreens.length > 0" class="nav nav-tabs" role="tablist">' +
        '<li v-for="tab in subscreens" :class="{active:tab.active,disabled:tab.disableLink}">' +
            '<span v-if="tab.disabled">{{tab.title}}</span>' +
            '<m-link v-else :href="tab.pathWithParams">{{tab.title}}</m-link>' +
        '</li>' +
    '</ul>',
    // use this with isActive(tab.path)?
    // methods: { isActive: function(path) { return (this.$root.currentPath.indexOf(path) == 0) } },
    computed: { subscreens: function() {
        if (!this.pathIndex || this.pathIndex < 0) return [];
        var navMenu = this.$root.navMenuList[this.pathIndex];
        return navMenu ? navMenu.subscreens : [];
    }},
    // this approach to get pathIndex won't work if the subscreens-active tag comes before subscreens-tabs
    mounted: function() { this.pathIndex = this.$root.activeSubscreens.length; }
});
Vue.component('subscreens-active', {
    data: function() { return { activeComponent:EmptyComponent, pathIndex:-1, pathName:null, menuComponent:null } },
    template: '<component :is="activeComponent"></component>',
    // setPathName is a method instead of a watch on pathName so that it runs even when newPath is the same
    methods: { setPathName: function(newPath) {
        this.pathName = newPath;
        if (!newPath || newPath.length === 0) { this.activeComponent = EmptyComponent; return; }
        var newUrl = this.$root.basePath + '/' + this.$root.currentPathList.slice(0, this.pathIndex + 1).join('/');
        var search = this.$root.currentSearch; if (search.length > 0) newUrl += ('?' + search);
        console.log('subscreens-active setPathName pathIndex ' + this.pathIndex + ' pathName ' + this.pathName + ' newUrl ' + newUrl);
        var vm = this; vm.$root.loading++;
        loadComponent(newUrl, function(comp) { vm.activeComponent = comp; vm.$root.loading--; });
    }},
    mounted: function() { this.$root.addSubscreen(this); }
});
const webrootVue = new Vue({
    el: '#apps-root',
    data: { basePath:"", linkBasePath:"", currentPathList:[], currentParameters:{}, activeSubscreens:[],
        navMenuList:[], navHistoryList:[], navPlugins:[], loading:0, activeContainers:{},
        moquiSessionToken:"", appHost:"", appRootPath:"", userId:"", notificationClient:null },
    methods: {
        goto: function (url) {
            // make sure any open modals are closed before setting currentUrl
            $('.modal.in').modal('hide');
            if (url.indexOf(this.basePath) == 0) url = url.replace(this.basePath, this.linkBasePath);
            // NOTE: this may have to change, don't set to empty first as kills the path diff based load
            if (this.currentUrl == url) {  this.currentUrl = ""; var vm = this; setTimeout(function() { vm.currentUrl = url; }, 10) }
            else { this.currentUrl = url; window.history.pushState(null, this.ScreenTitle, url); }
        },
        addSubscreen: function(saComp) {
            var pathIdx = this.activeSubscreens.length;
            // setting pathName here handles initial load of subscreens-active
            console.log('addSubscreen idx ' + pathIdx + ' pathName ' + this.currentPathList[pathIdx]);
            saComp.pathIndex = pathIdx;
            // this may be undefined if we have more activeSubscreens than currentPathList items
            saComp.setPathName(this.currentPathList[pathIdx]);
            this.activeSubscreens.push(saComp);
        },
        // all container components added with this must have reload() and load(url) methods
        addContainer: function(contId, comp) { this.activeContainers[contId] = comp; },
        reloadContainer: function(contId) { var contComp = this.activeContainers[contId];
            if (contComp) { contComp.reload(); } else { console.log("Container with ID " + contId + " not found, not reloading"); }},
        loadContainer: function(contId, url) { var contComp = this.activeContainers[contId];
            if (contComp) { contComp.load(url); } else { console.log("Container with ID " + contId + " not found, not loading url " + url); }},
        addNavPlugin: function(url) { var vm = this; loadComponent(url, function(comp) { vm.navPlugins.push(comp); }) },
        switchDarkLight: function() {
            var jqBody = $("body"); jqBody.toggleClass("bg-dark"); jqBody.toggleClass("bg-light");
            var currentStyle = jqBody.hasClass("bg-dark") ? "bg-dark" : "bg-light";
            $.ajax({ type:'POST', url:'/apps/setPreference', data:{ moquiSessionToken: this.moquiSessionToken,
                preferenceKey:'OUTER_STYLE', preferenceValue:currentStyle } });
        }
    },
    watch: {
        currentUrl: function(newUrl) {
            if (!newUrl || newUrl.length === 0) return;
            var vm = this;
            console.log("currentUrl changing to " + newUrl);
            // TODO: somehow only clear out activeContainers that are in subscreens actually reloaded? may cause issues if any but last screen have dynamic-container
            this.activeContainers = {};
            // update menu
            $.ajax({ type:"GET", url:"/menuData" + newUrl, dataType:"json", error:handleAjaxError, success: function(outerList) {
                if (outerList) { vm.navMenuList = outerList; } }});
            // active screen updates when currentPathList is updated activeSubscreens is populated
        },
        navMenuList: function(newList) { if (newList.length > 0) {
            var cur = newList[newList.length - 1]; var par = newList.length > 1 ? newList[newList.length - 2] : null;
            // make sure full currentPathList and activeSubscreens is populated (necessary for minimal path urls)
            var basePathSize = this.basePath.split('/').length;
            var fullPathList = cur.path.split('/').slice(basePathSize);
            console.log('nav updated fullPath ' + JSON.stringify(fullPathList) + ' currentPathList ' + JSON.stringify(this.currentPathList));
            if (this.currentPathList.length < fullPathList.length) {
                var tempList = this.currentPathList.slice(0);
                for (var fpi=tempList.length; fpi<fullPathList.length; fpi++) { tempList.splice(fpi, 0, fullPathList[fpi]); }
                this.currentPathList = tempList;
            }
            // update history and document.title
            var newTitle = (par ? par.title + ' - ' : '') + cur.title;
            var curUrl = cur.pathWithParams; var questIdx = curUrl.indexOf("?");
            if (questIdx > 0) {
                var parmList = curUrl.substring(questIdx+1).split("&");
                curUrl = curUrl.substring(0, questIdx);
                var dpCount = 0; var titleParms = "";
                for (var pi=0; pi<parmList.length; pi++) {
                    var parm = parmList[pi]; if (parm.indexOf("pageIndex=") == 0) continue;
                    if (curUrl.indexOf("?") == -1) { curUrl += "?"; } else { curUrl += "&"; }
                    curUrl += parm;
                    if (dpCount > 1) continue; // add up to 2 parms to the title
                    var eqIdx = parm.indexOf("=");
                    if (eqIdx > 0) {
                        var key = parm.substring(0, eqIdx);
                        if (key.indexOf("_op") > 0 || key.indexOf("_not") > 0 || key.indexOf("_ic") > 0 || key == "moquiSessionToken") continue;
                        if (titleParms.length > 0) titleParms += ", ";
                        titleParms += parm.substring(eqIdx + 1);
                    }
                }
                if (titleParms.length > 0) newTitle = newTitle + " (" + titleParms + ")";
            }
            for (var i=0; i<this.navHistoryList.length;) {
                if (this.navHistoryList[i].pathWithParams == curUrl) { this.navHistoryList.splice(i,1); } else { i++; } }
            this.navHistoryList.unshift({ title:newTitle, pathWithParams:curUrl, image:cur.image, imageType:cur.imageType });
            while (this.navHistoryList.length > 25) { this.navHistoryList.pop(); }
            document.title = newTitle;
        }},
        currentPathList: function(newList) {
            console.log('set currentPathList to ' + JSON.stringify(newList) + ' activeSubscreens.length ' + this.activeSubscreens.length);
            if (newList.length == 0 && this.activeSubscreens.length > 0) { this.activeSubscreens[0].setPathName(null); this.activeSubscreens.splice(1); return; }
            for (var i=0; i<this.activeSubscreens.length; i++) {
                if (i >= newList.length) break;
                var newName = newList[i];
                var curName = this.activeSubscreens[i].pathName;
                // console.log('set currentPathList idx ' + i + ' curName ' + curName + ' newName ' + newName);
                if (newName != curName || i == (newList.length - 1)) {
                    // update the pathName at the current position to load the new component
                    this.activeSubscreens[i].setPathName(newName);
                    // clear out remaining activeSubscreens, after first changed loads its placeholders will register and load
                    this.activeSubscreens.splice(i+1);
                }
            }
        }
    },
    computed: {
        currentPath: {
            get: function() { return this.basePath + '/' + this.currentPathList.join('/'); },
            set: function(newPath) {
                if (!newPath || newPath.length == 0) { this.currentPathList = []; return; }
                var basePathSize = this.basePath.split('/').length;
                this.currentPathList = newPath.split('/').slice(basePathSize);
            }},
        currentSearch: {
            get: function() { var search = ''; $.each(this.currentParameters, function (key, value) {
                search = search + (search.length > 0 ? '&' : '') + key + '=' + value; }); return search; },
            set: function(newSearch) {
                this.currentParameters = {}; if (!newSearch || newSearch.length == 0) { return; }
                var parmList = newSearch.split("&");
                for (var i=0; i<parmList.length; i++) {
                    var parm = parmList[i]; var ps = parm.split("="); if (ps.length > 1) { this.currentParameters[ps[0]] = ps[1]; } }
            }},
        currentUrl: {
            get: function() { var srch = this.currentSearch; return this.currentPath + (srch.length > 0 ? '?' + this.currentSearch : ''); },
            set: function(href) {
                var ssIdx = href.indexOf('//');
                if (ssIdx >= 0) { var slIdx = href.indexOf('/', ssIdx + 1); if (slIdx == -1) { return; } href = href.slice(slIdx); }
                var splitHref = href.split("?");
                // set currentSearch before currentPath so that it is available when path updates
                if (splitHref.length > 1 && splitHref[1].length > 0) { this.currentSearch = splitHref[1]; } else { this.currentSearch = ""; }
                this.currentPath = splitHref[0];
            }
        },
        ScreenTitle: function() { return this.navMenuList.length > 0 ? this.navMenuList[this.navMenuList.length - 1].title : ""; }
    },
    components: {
        'add-nav-plugin': { props:{url:{type:String,required:true}}, template:'<span></span>',
            mounted:function() { this.$root.addNavPlugin(this.url); Vue.util.remove(this.$el); }}
    },
    created: function() {
        this.moquiSessionToken = $("#moquiSessionToken").val();
        this.appHost = $("#appHost").val(); this.appRootPath = $("#appRootPath").val();
        this.basePath = $("#basePath").val(); this.linkBasePath = $("#linkBasePath").val();
        this.userId = $("#userId").val();
        this.notificationClient = new NotificationClient("ws://" + this.appHost + this.appRootPath + "/notws");
    },
    mounted: function() {
        $('.navbar [data-toggle="tooltip"]').tooltip();
        $('#history-menu-link').tooltip({ placement:'bottom', trigger:'hover' });
        // load the current screen
        this.currentUrl = window.location.pathname + window.location.search;
        // init the NotificationClient and register 'displayNotify' as the default listener
        this.notificationClient.registerListener("ALL");
    }
});
window.addEventListener('popstate', function() { webrootVue.currentUrl = window.location.pathname + window.location.search; });
